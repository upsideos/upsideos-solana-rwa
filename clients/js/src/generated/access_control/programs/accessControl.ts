/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedBurnSecuritiesInstruction,
  type ParsedForceTransferBetweenInstruction,
  type ParsedFreezeWalletInstruction,
  type ParsedGrantRoleInstruction,
  type ParsedInitializeAccessControlInstruction,
  type ParsedMintSecuritiesInstruction,
  type ParsedRevokeRoleInstruction,
  type ParsedSetLockupEscrowAccountInstruction,
  type ParsedSetMaxTotalSupplyInstruction,
  type ParsedThawWalletInstruction,
} from '../instructions';

export const ACCESS_CONTROL_PROGRAM_ADDRESS =
  '4X79YRjz9KNMhdjdxXg2ZNTS3YnMGYdwJkBHnezMJwr3' as Address<'4X79YRjz9KNMhdjdxXg2ZNTS3YnMGYdwJkBHnezMJwr3'>;

export enum AccessControlAccount {
  AccessControl,
  WalletRole,
}

export function identifyAccessControlAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): AccessControlAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([147, 81, 178, 92, 223, 66, 181, 132])
      ),
      0
    )
  ) {
    return AccessControlAccount.AccessControl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 71, 35, 217, 102, 248, 173, 9])
      ),
      0
    )
  ) {
    return AccessControlAccount.WalletRole;
  }
  throw new Error(
    'The provided account could not be identified as a accessControl account.'
  );
}

export enum AccessControlInstruction {
  BurnSecurities,
  ForceTransferBetween,
  FreezeWallet,
  GrantRole,
  InitializeAccessControl,
  MintSecurities,
  RevokeRole,
  SetLockupEscrowAccount,
  SetMaxTotalSupply,
  ThawWallet,
}

export function identifyAccessControlInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): AccessControlInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([79, 165, 145, 57, 203, 228, 175, 0])
      ),
      0
    )
  ) {
    return AccessControlInstruction.BurnSecurities;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([186, 115, 85, 7, 217, 111, 254, 108])
      ),
      0
    )
  ) {
    return AccessControlInstruction.ForceTransferBetween;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([93, 202, 159, 167, 22, 246, 255, 211])
      ),
      0
    )
  ) {
    return AccessControlInstruction.FreezeWallet;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([218, 234, 128, 15, 82, 33, 236, 253])
      ),
      0
    )
  ) {
    return AccessControlInstruction.GrantRole;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([244, 90, 245, 242, 199, 224, 247, 140])
      ),
      0
    )
  ) {
    return AccessControlInstruction.InitializeAccessControl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 195, 58, 36, 142, 195, 14, 225])
      ),
      0
    )
  ) {
    return AccessControlInstruction.MintSecurities;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([179, 232, 2, 180, 48, 227, 82, 7])
      ),
      0
    )
  ) {
    return AccessControlInstruction.RevokeRole;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([134, 172, 249, 223, 25, 118, 55, 93])
      ),
      0
    )
  ) {
    return AccessControlInstruction.SetLockupEscrowAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([249, 164, 34, 254, 160, 89, 214, 12])
      ),
      0
    )
  ) {
    return AccessControlInstruction.SetMaxTotalSupply;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([79, 251, 128, 221, 55, 172, 181, 221])
      ),
      0
    )
  ) {
    return AccessControlInstruction.ThawWallet;
  }
  throw new Error(
    'The provided instruction could not be identified as a accessControl instruction.'
  );
}

export type ParsedAccessControlInstruction<
  TProgram extends string = '4X79YRjz9KNMhdjdxXg2ZNTS3YnMGYdwJkBHnezMJwr3',
> =
  | ({
      instructionType: AccessControlInstruction.BurnSecurities;
    } & ParsedBurnSecuritiesInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.ForceTransferBetween;
    } & ParsedForceTransferBetweenInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.FreezeWallet;
    } & ParsedFreezeWalletInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.GrantRole;
    } & ParsedGrantRoleInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.InitializeAccessControl;
    } & ParsedInitializeAccessControlInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.MintSecurities;
    } & ParsedMintSecuritiesInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.RevokeRole;
    } & ParsedRevokeRoleInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.SetLockupEscrowAccount;
    } & ParsedSetLockupEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.SetMaxTotalSupply;
    } & ParsedSetMaxTotalSupplyInstruction<TProgram>)
  | ({
      instructionType: AccessControlInstruction.ThawWallet;
    } & ParsedThawWalletInstruction<TProgram>);
