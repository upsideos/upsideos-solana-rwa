/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedCancelTimelockInstruction,
  type ParsedCreateReleaseScheduleInstruction,
  type ParsedInitializeTimelockInstruction,
  type ParsedInitializeTokenlockInstruction,
  type ParsedMintReleaseScheduleInstruction,
  type ParsedTransferInstruction,
  type ParsedTransferTimelockInstruction,
} from '../instructions';

export const TOKENLOCK_PROGRAM_ADDRESS =
  'AoodM6rkg968933giHnigMEwp9kiGi68ZEx9bPqk71Gt' as Address<'AoodM6rkg968933giHnigMEwp9kiGi68ZEx9bPqk71Gt'>;

export enum TokenlockAccount {
  AccessControl,
  TimelockData,
  TokenLockData,
  TransferRestrictionData,
  WalletRole,
}

export function identifyTokenlockAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TokenlockAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([147, 81, 178, 92, 223, 66, 181, 132])
      ),
      0
    )
  ) {
    return TokenlockAccount.AccessControl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([166, 255, 48, 254, 36, 155, 55, 132])
      ),
      0
    )
  ) {
    return TokenlockAccount.TimelockData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([21, 223, 206, 135, 104, 58, 210, 120])
      ),
      0
    )
  ) {
    return TokenlockAccount.TokenLockData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([166, 184, 205, 98, 165, 224, 174, 148])
      ),
      0
    )
  ) {
    return TokenlockAccount.TransferRestrictionData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 71, 35, 217, 102, 248, 173, 9])
      ),
      0
    )
  ) {
    return TokenlockAccount.WalletRole;
  }
  throw new Error(
    'The provided account could not be identified as a tokenlock account.'
  );
}

export enum TokenlockInstruction {
  CancelTimelock,
  CreateReleaseSchedule,
  InitializeTimelock,
  InitializeTokenlock,
  MintReleaseSchedule,
  Transfer,
  TransferTimelock,
}

export function identifyTokenlockInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TokenlockInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([158, 180, 47, 81, 133, 231, 168, 238])
      ),
      0
    )
  ) {
    return TokenlockInstruction.CancelTimelock;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([244, 168, 39, 240, 234, 71, 104, 108])
      ),
      0
    )
  ) {
    return TokenlockInstruction.CreateReleaseSchedule;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([47, 125, 243, 32, 170, 86, 24, 243])
      ),
      0
    )
  ) {
    return TokenlockInstruction.InitializeTimelock;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([7, 16, 90, 167, 17, 36, 129, 147])
      ),
      0
    )
  ) {
    return TokenlockInstruction.InitializeTokenlock;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([124, 157, 84, 33, 123, 128, 222, 184])
      ),
      0
    )
  ) {
    return TokenlockInstruction.MintReleaseSchedule;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([163, 52, 200, 231, 140, 3, 69, 186])
      ),
      0
    )
  ) {
    return TokenlockInstruction.Transfer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([197, 69, 160, 26, 96, 251, 228, 192])
      ),
      0
    )
  ) {
    return TokenlockInstruction.TransferTimelock;
  }
  throw new Error(
    'The provided instruction could not be identified as a tokenlock instruction.'
  );
}

export type ParsedTokenlockInstruction<
  TProgram extends string = 'AoodM6rkg968933giHnigMEwp9kiGi68ZEx9bPqk71Gt',
> =
  | ({
      instructionType: TokenlockInstruction.CancelTimelock;
    } & ParsedCancelTimelockInstruction<TProgram>)
  | ({
      instructionType: TokenlockInstruction.CreateReleaseSchedule;
    } & ParsedCreateReleaseScheduleInstruction<TProgram>)
  | ({
      instructionType: TokenlockInstruction.InitializeTimelock;
    } & ParsedInitializeTimelockInstruction<TProgram>)
  | ({
      instructionType: TokenlockInstruction.InitializeTokenlock;
    } & ParsedInitializeTokenlockInstruction<TProgram>)
  | ({
      instructionType: TokenlockInstruction.MintReleaseSchedule;
    } & ParsedMintReleaseScheduleInstruction<TProgram>)
  | ({
      instructionType: TokenlockInstruction.Transfer;
    } & ParsedTransferInstruction<TProgram>)
  | ({
      instructionType: TokenlockInstruction.TransferTimelock;
    } & ParsedTransferTimelockInstruction<TProgram>);
